package com.serverless.dal;

import java.io.IOException;
import java.util.HashMap;
import java.util.List;

import org.apache.log4j.Logger;

import com.amazonaws.services.dynamodbv2.AmazonDynamoDB;
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBAttribute;
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBAutoGeneratedKey;
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBHashKey;
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBIndexHashKey;
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBMapper;
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBMapperConfig;
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBQueryExpression;
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBRangeKey;
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBScanExpression;
import com.amazonaws.services.dynamodbv2.datamodeling.DynamoDBTable;
import com.amazonaws.services.dynamodbv2.datamodeling.PaginatedQueryList;
import com.amazonaws.services.dynamodbv2.model.AttributeValue;

@DynamoDBTable(tableName = "PLACEHOLDER_USER_TABLE_NAME")
public class User {
	// get the table name from env. var. set in serverless.yml
	private static final String USER_TABLE_NAME = System.getenv("USER_TABLE_NAME");

	private static DynamoDBAdapter db_adapter;
	private final AmazonDynamoDB client;
	private final DynamoDBMapper mapper;

	private Logger logger = Logger.getLogger(this.getClass());

	private String id;
	private String name;
	private String password;
	private String phone;
	private String address;
	private String email;
	private String user_role;

	@DynamoDBHashKey(attributeName = "id")
	@DynamoDBAutoGeneratedKey
	public String getId() {
		return this.id;
	}

	public void setId(String id) {
		this.id = id;
	}

	@DynamoDBIndexHashKey(attributeName = "name", globalSecondaryIndexName = "name-index")
	@DynamoDBAttribute(attributeName = "name")
	public String getName() {
		return this.name;
	}

	public void setName(String name) {
		this.name = name;
	}

	@DynamoDBAttribute(attributeName = "password")
	public String getPassword() {
		return password;
	}

	public void setPassword(String password) {
		this.password = password;
	}

	@DynamoDBAttribute(attributeName = "phone")
	public String getPhone() {
		return phone;
	}

	public void setPhone(String phone) {
		this.phone = phone;
	}

	@DynamoDBAttribute(attributeName = "address")
	public String getAddress() {
		return address;
	}

	public void setAddress(String address) {
		this.address = address;
	}

	@DynamoDBAttribute(attributeName = "email")
	public String getEmail() {
		return email;
	}

	public void setEmail(String email) {
		this.email = email;
	}

	@DynamoDBAttribute(attributeName = "user_role")
	public String getUser_role() {
		return user_role;
	}

	public void setUser_role(String user_role) {
		this.user_role = user_role;
	}

	public User() {
		// build the mapper config
		DynamoDBMapperConfig mapperConfig = DynamoDBMapperConfig.builder()
				.withTableNameOverride(new DynamoDBMapperConfig.TableNameOverride(USER_TABLE_NAME)).build();
		// get the db adapter
		this.db_adapter = DynamoDBAdapter.getInstance();
		this.client = this.db_adapter.getDbClient();
		// create the mapper with config
		this.mapper = this.db_adapter.createDbMapper(mapperConfig);
	}

	// methods
	public Boolean ifTableExists() {
		return this.client.describeTable(USER_TABLE_NAME).getTable().getTableStatus().equals("ACTIVE");
	}

	public List<User> list() throws IOException {
		DynamoDBScanExpression scanExp = new DynamoDBScanExpression();
		List<User> results = this.mapper.scan(User.class, scanExp);
		for (User p : results) {
			logger.info("Users - list(): " + p.toString());
		}
		return results;
	}

	public User get(String id) throws IOException {
		User user = null;

		HashMap<String, AttributeValue> av = new HashMap<String, AttributeValue>();
		av.put(":v1", new AttributeValue().withS(id));

		DynamoDBQueryExpression<User> queryExp = new DynamoDBQueryExpression<User>()
				.withKeyConditionExpression("id = :v1").withExpressionAttributeValues(av);

		PaginatedQueryList<User> result = this.mapper.query(User.class, queryExp);
		if (result.size() > 0) {
			user = result.get(0);
			logger.info("Users - get(): User - " + user.toString());
		} else {
			logger.info("Users - get(): User - Not Found.");
		}
		return user;
	}
	public User getUserByEmail(String email) {
		User user = null;

		HashMap<String, AttributeValue> av = new HashMap<String, AttributeValue>();
		av.put(":v1", new AttributeValue().withS(email));

		DynamoDBQueryExpression<User> queryExp = new DynamoDBQueryExpression<User>()
				.withKeyConditionExpression("email = :v1").withExpressionAttributeValues(av);

		PaginatedQueryList<User> result = this.mapper.query(User.class, queryExp);
		if (result.size() > 0) {
			user = result.get(0);
			logger.info("Users - getUserByEmail(): User - " + user.toString());
		} else {
			logger.info("Users - getUserByEmail(): User - Not Found.");
		}
		return user;
	}

	public void save(User user) throws IOException {
		logger.info("Users - save(): " + user.toString());
		this.mapper.save(user);
	}

	public void update(User user) throws IOException {
		logger.info("Users - update(): " + user.toString());

		DynamoDBMapperConfig dynamoDBMapperConfig = new DynamoDBMapperConfig.Builder()
				.withConsistentReads(DynamoDBMapperConfig.ConsistentReads.CONSISTENT)
				.withSaveBehavior(DynamoDBMapperConfig.SaveBehavior.UPDATE).build();
		this.mapper.save(user, dynamoDBMapperConfig);
	}

	public Boolean delete(String id) throws IOException {
		User User = null;

		// get User if exists
		User = get(id);
		if (User != null) {
			logger.info("Users - delete(): " + User.toString());
			this.mapper.delete(User);
		} else {
			logger.info("Users - delete(): User - does not exist.");
			return false;
		}
		return true;
	}

}
